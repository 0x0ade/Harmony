<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Patching </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Patching ">
    <meta name="generator" content="docfx 2.40.12.0">
    
    <link rel="shortcut icon" href="../favicon.ico">
    <link rel="stylesheet" href="../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../styles/docfx.css">
    <link rel="stylesheet" href="../styles/main.css">
    <meta property="docfx:navrel" content="../toc.html">
    <meta property="docfx:tocrel" content="toc.html">
    
    
    
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../index.html">
                <img id="logo" class="svg" src="../logo.svg" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
<h1 id="patching">Patching</h1>

<h2 id="concept">Concept</h2>
<p>In order to provide your own code to Harmony, you need to define methods that run in the context of the original method. Harmony provides three types of methods that each offer different possibilities.</p>
<h4 id="main-types-of-patches">Main types of patches</h4>
<p>Two of them, <strong>Prefix</strong> and <strong>Postfix</strong> are high level and you can write them as simple static methods. The third, called <strong>Transpiler</strong>, is not a method that is executed together with the original but called in an earlier stage where the instructions of the original are fed into the transpiler so it can process and change them, to finally output the instructions that will build the new original.</p>
<h4 id="patches-need-to-be-static">Patches need to be static</h4>
<p>Patch methods need to be static because Harmony works with multiple users in different assemblies in mind. In order to guarantee the correct patching order, patches are always re-applied as soon as someone wants to change the original. Since it is hard to serialize data in a generic way across assemblies in .NET, Harmony only stores a method pointer to your patch methods so it can use and apply them at a later point again.</p>
<p>If you need custom state in your patches, it is recommended to use a static variable and store all your patch state in there. Keep in mind that Transpilers are only executed to generate the method so they don't &quot;run&quot; when the original is executed.</p>
<h2 id="patch-class">Patch Class</h2>
<p>With manual patching, you can put your patches anywhere you like. Patching by annotations simplifies patching by assuming you create one class for each patched original and define your patch methods inside it. The name of the class can be arbitrary but a common way to name them is <code>OriginalClass_OriginalMethodName_Patch</code>.</p>
<p>The class can be static or not, public or private, it doesn't matter. However, in order to make Harmony find it, it must have at least one <code>[HarmonyPatch]</code> attribute. Inside the class you can define as many methods as you want and some of them should be (static) patch methods.</p>
<p>The attributes of the methods in the class inherit the attributes of the class.</p>
<h2 id="patch-methods">Patch methods</h2>
<p>Harmony identifies your patch methods and their helper methods <strong>by name</strong>. If you prefer to name your methods differently, you can use attributes to tell Harmony what your methods are.</p>
<pre><code class="lang-csharp">[HarmonyPatch(...)]
class Patch
{
    static void Prefix()
    {
        // this method uses the name &quot;Prefix&quot;, no annotation necessary
    }

    [HarmonyPostfix]
    static void MyOwnName()
    {
        // this method is a Postfix as defined by the attribute
    }
}
</code></pre>
<p>If you prefer manual patching, you can use any method name or class structure you want. You are responsible to retrieve the MethodInfo for the different patch methods and supply them to the Patch() method by wrapping them into HarmonyMethod objects.</p>
<p><img src="https://raw.githubusercontent.com/pardeike/Harmony/master/Harmony/Documentation/images/note.png" alt="note"> Patch methods <em>must</em> be static but you can define them public or private. They cannot be dynamic methods but you can write static patch factory methods that return dynamic methods.</p>
<h3 id="method-names">Method names</h3>
<p>Manual patching knows only three main patch types: <strong>Prefix</strong>, <strong>Postfix</strong> and <strong>Transpiler</strong>. If you use attributes for patching, you can also use the helper methods: <strong>Prepare</strong>, <strong>TargetMethod</strong>, <strong>TargetMethods</strong> and <strong>Cleanup</strong> as explained below.</p>
<p>Each of those names has a corresponding attribute starting with [Harmony...]. So instead of calling one of your methods &quot;Prepare&quot;, you can call it anything and decorate it with a <code>[HarmonyPrepare]</code> attribute.</p>
<h2 id="patch-method-types">Patch method types</h2>
<p>Both prefix and postfix have specific semantics that are unique to them. They do however share the ability to use a range of injected values as arguments. Those are listed after the discussion of prefix and postfix.</p>
<h3 id="prefix">Prefix</h3>
<p>A prefix is a method that is executed before the original method. It is commonly used to:</p>
<ul>
<li>access and edit the arguments of the original method</li>
<li>set the result of the original method</li>
<li>skip the original method</li>
<li>set custom state that can be recalled in the postfix</li>
</ul>
<p><img src="https://raw.githubusercontent.com/pardeike/Harmony/master/Harmony/Documentation/images/note.png" alt="note"> The first prefix that skips the original will skip all remaining prefixes too. Postfixes are not affected.</p>
<h4 id="reading-and-changing-arguments">Reading and changing arguments</h4>
<pre><code class="lang-csharp">public class OriginalCode
{
    public void Test(int counter, string name)
    {
        // ...
    }
}

[HarmonyPatch(typeof(OriginalCode), &quot;Test&quot;)]
class Patch
{
    static void Prefix(int counter, ref string name)
    {  
        FileLog.Log(&quot;counter = &quot; + counter); // read
        name = &quot;test&quot;; // write with ref keyword
    }
}
</code></pre>
<h4 id="changing-the-result-and-skipping-the-original">Changing the result and skipping the original</h4>
<p>To change the result of the original, use <code>__result</code> as an argument of your prefix. It must match the return type or be assignable from it. Changing the result of the original does not make sense if you let the original run so skipping the original is necessary too.</p>
<p>To skip the original, let the prefix return a <code>bool</code> and return <code>true</code> to let the original run after all prefixes or <code>false</code> to stop executing prefixes and skip the original. Postfixes will always be executed.</p>
<p><img src="https://raw.githubusercontent.com/pardeike/Harmony/master/Harmony/Documentation/images/note.png" alt="note"> It is not recommended to skip the original unless you want to completely change the way it works. If you only want a small change or a side effect, using a postfix or a transpiler is always preferred since it allows for multiple users changing the original without each implementation fighting over how the original should behave.</p>
<pre><code class="lang-csharp">public class OriginalCode
{
    public string GetName()
    {
        // ...
    }
}

[HarmonyPatch(typeof(OriginalCode), &quot;GetName&quot;)]
class Patch
{
    static bool Prefix(ref string __result)
    {  
        __result = &quot;test&quot;;
        return true; // make sure you only skip if really necessary
    }
}
</code></pre>
<p>Some users have trouble understanding the disconnect between altering what the original method returns and what the Prefix returns. The following example is meant to illustrate that the boolean return value of the Prefix only determines if the original gets run or not.</p>
<pre><code class="lang-csharp">public class OriginalCode
{
    public bool IsFullAfterTakingIn(int i)
    {
        // do expensive calculations
    }
}

[HarmonyPatch(typeof(OriginalCode), &quot;IsFullAfterTakingIn&quot;)]
class Patch
{
    static bool Prefix(ref bool __result, int i)
    {  
        if (i &gt; 5)
        {
            __result = true; // any call to IsFullAfterTakingIn(i) where i &gt; 5 now immediately returns true
	    return false; // skips the original and its expensive calculations
        }
        return true; // make sure you only skip if really necessary
    }
}
</code></pre>
<h4 id="passing-state-between-prefix-and-postfix">Passing state between prefix and postfix</h4>
<p>If you want to share state between your prefix and the corresponding postfix, you can use <code>__state</code> (with the <code>ref</code> or <code>out</code> keyword). If you need more than one value you can create your own type and pass it instead.</p>
<pre><code class="lang-cs">public class OriginalCode
{
    public void Test(int counter, string name)
    {
        // ...
    }
}

[HarmonyPatch(typeof(OriginalCode), &quot;Test&quot;)]
class Patch
{
    // this example uses a Stopwatch type to measure
    // and share state between prefix and postfix

    static void Prefix(out Stopwatch __state)
    {  
        __state = new Stopwatch(); // assign your own state
        __state.Start();
    }

    static void Postfix(Stopwatch __state)
    {  
        __state.Stop();
        FileLog.Log(__state.Elapsed);
    }
}
</code></pre>
<h3 id="postfix">Postfix</h3>
<p>A postfix is a method that is executed after the original method. It is commonly used to:</p>
<ul>
<li>read or change the result of the original method</li>
<li>access the arguments of the original method</li>
<li>make sure your code is always executed</li>
<li>read custom state from the prefix</li>
</ul>
<h4 id="reading-or-changing-the-result">Reading or changing the result</h4>
<p>Since the postfix has access to the result of the original (or a prefix that has skipped the original), it can read or alter the result by using the argument <code>__result</code>. It must match the return type of the original or be assignable from it.</p>
<pre><code class="lang-csharp">public class OriginalCode
{
    public string GetName()
    {
        // ...
    }
}

[HarmonyPatch(typeof(OriginalCode), &quot;GetName&quot;)]
class Patch
{
    static void Postfix(ref string __result)
    {  
        if (__result == &quot;foo&quot;)
            __result = &quot;bar&quot;;
    }
}
</code></pre>
<h4 id="pass-through-postfixes">Pass through postfixes</h4>
<p>An alternative way to change the result of an original method is to use a <strong>pass through</strong> postfix. A pass through postfix has a non-void return type that matches the type of the first argument.</p>
<p>Harmony will call the postfix with the result of the original and will use the result of the postfix to continue. Since this works for all types, it is especially useful for types like <code>IEnumerable&lt;T&gt;</code> that cannot be combined with <code>ref</code>. This allows for changing the result with <code>yield</code> operations.</p>
<pre><code class="lang-csharp">public class OriginalCode
{
    public string GetName()
    {
        return &quot;David&quot;;
    }

    public IEnumerable&lt;int&gt; GetNumbers()
    {
        yield return 1;
        yield return 2;
    }
}

[HarmonyPatch(typeof(OriginalCode), &quot;GetName&quot;)]
class Patch1
{
    static string Postfix(string name)
    {  
        return &quot;Hello &quot; + name;
    }
}

[HarmonyPatch(typeof(OriginalCode), &quot;GetNumbers&quot;)]
class Patch2
{
    static IEnumerable&lt;int&gt; Postfix(IEnumerable&lt;int&gt; values)
    {  
        yield return 0;
        foreach (var value in values)
            yield return value;
        yield return 99;
    }
}
</code></pre>
<h4 id="reading-original-arguments">Reading original arguments</h4>
<pre><code class="lang-csharp">public class OriginalCode
{
    public void Test(int counter)
    {
        // ...
    }
}

[HarmonyPatch(typeof(OriginalCode), &quot;Test&quot;)]
class Patch
{
    static void Prefix(int counter)
    {  
        FileLog.Log(&quot;counter = &quot; + counter);
    }
}
</code></pre>
<h4 id="postfixes-always-run">Postfixes always run</h4>
<p>Harmony will not skip any postfix regardless of what any prefix or the original method do. It is good style to use postfixes as much as possible since they lead to more compatible code.</p>
<h4 id="passing-state-between-prefix-and-postfix-1">Passing state between prefix and postfix</h4>
<p>See prefix</p>
<h3 id="common-injected-values">Common injected values</h3>
<p>Each prefix and postfix can get all the arguments of the original method as well as the instance (if original method is not static) and the return value. Patches can define only those parameters they want to access.</p>
<h4 id="instance">Instance</h4>
<p>Patches can use an argument named <code>__instance</code> to access the instance value if original method is not static. This is similar to the C# keyword <code>this</code> where used in the original method.</p>
<h4 id="result">Result</h4>
<p>Patches can use an argument named <code>__result</code> to access the returned value. The type <code>T</code> of argument must match the return type of the original or be assignable from it. For prefixes, as the original method hasn't run yet, the value of <code>__result</code> is default(T). For most reference types, that would be <code>null</code>. If you wish to alter the <code>__result</code>, you need to pass it by <code>ref</code>.</p>
<h4 id="state">State</h4>
<p>Patches can use an argument named <code>__state</code> to store information in the prefix method that can be accessed again in the postfix method. Think of it as a local variable. It can be any type and you are responsible to initialize its value in the prefix.</p>
<h4 id="private-fields">(Private) Fields</h4>
<p>Argument names starting with three underscores, for example <code>___someField</code>, can be used to read and (with <code>ref</code>) write private fields on the instance that has the corresponding name (minus the underscores).</p>
<h4 id="argument-types">Argument types</h4>
<p>Arguments from the original must use the exact same name and type as the original method but using <code>object</code> is ok too.</p>
<h4 id="the-original">The original</h4>
<p>To allow patch reusing, one can inject the original method by using an argument named <code>__originalMethod</code>.</p>
<h4 id="special-arguments">Special arguments</h4>
<p>In transpilers, arguments are only matched by their type so you can choose any argument name you like.</p>
<p>An argument of type <code>IEnumerable&lt;CodeInstruction&gt;</code> is required and will be used to pass the IL codes to the transpiler
An argument of type <code>ILGenerator</code> will be set to the current IL code generator
An argument of type <code>MethodBase</code> will be set to the current original method being patched</p>
<h3 id="transpiler">Transpiler</h3>
<p>This method defines the transpiler that modifies the code of the original method. Use this in the advanced case where you want to modify the original methods IL codes.</p>
<pre><code class="lang-csharp">static IEnumerable&lt;CodeInstruction&gt; Transpiler(IEnumerable&lt;CodeInstruction&gt; instr, ...)
// or
[HarmonyTranspiler]
static IEnumerable&lt;CodeInstruction&gt; MyTranspiler(IEnumerable&lt;CodeInstruction&gt; instr, ...)
</code></pre>
<p>+++</p>
<h2 id="auxilary-patch-methods">Auxilary patch methods</h2>
<h3 id="prepare">Prepare</h3>
<p>Before the patching, Harmony gives you a chance to prepare your state. For this, Harmony searches for a method called</p>
<pre><code class="lang-csharp">static bool Prepare()
static bool Prepare(HarmonyInstance instance)
// or
[HarmonyPrepare]
static bool MyInitializer(...)
</code></pre>
<p>That method, if it exists, is expected to return a boolean that controls if patching will happen. You can optionally receive the harmony instance if you want to run other Harmony methods inside your code.</p>
<h3 id="targetmethod">TargetMethod</h3>
<p>Most of the times, you will use a combination of <code>HarmonyPatch()</code> annotations on the class to define the method you want to patch. Sometimes though, it is necessary to calculate the method with code. For this, Harmony searches for a method called</p>
<pre><code class="lang-csharp">static MethodBase TargetMethod()
static MethodBase TargetMethod(HarmonyInstance instance)
// or
[HarmonyTargetMethod]
// NOTE: not passing harmony instance with attributes is broken in 1.2.0.1
static MethodBase CalculateMethod(HarmonyInstance instance)
</code></pre>
<p>That method, if it exists, is expected to return a <code>MethodInfo</code> of the method to be patched. You can optionally receive the harmony instance if you want to run other Harmony methods inside your code.</p>
<h3 id="targetmethods">TargetMethods</h3>
<p>+++</p>
<h3 id="cleanup">Cleanup</h3>
<p>+++</p>
</article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                  <li>
                    <a href="https://github.com/pardeike/Harmony/blob/master/Harmony/Documentation/articles/patching.md/#L1" class="contribution-link">Improve this Doc</a>
                  </li>
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              <!-- <p><a class="back-to-top" href="#top">Back to top</a><p> -->
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            
            <span>Generated by <strong>DocFX</strong></span>
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../styles/docfx.js"></script>
    <script type="text/javascript" src="../styles/main.js"></script>
  </body>
</html>
